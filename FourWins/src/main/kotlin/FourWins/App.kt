/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package FourWins

import io.javalin.Javalin
import io.javalin.http.Context
import io.javalin.websocket.WsConnectContext
import io.javalin.websocket.WsContext
import org.eclipse.jetty.server.session.DefaultSessionCache
import org.eclipse.jetty.server.session.FileSessionDataStore
import org.eclipse.jetty.server.session.SessionHandler
import kotlin.coroutines.*

import kotlin.system.measureTimeMillis

class App {
    private val userUsernameMap = HashMap<WsContext, String>()
    private var nextUserNumber = 1
    lateinit var session: WsConnectContext
    var game: FourWins
    var canPlay = true

    init {
        game = FourWins()
        val app = Javalin.create { config ->
            config.addStaticFiles("/public")

        }.start(7070)

        app.apply {
            ws("/") { ws ->
                ws.onConnect { ctx ->
                    session = ctx
                    ctx.send("0 " + game.toString())
                }
                ws.onClose { ctx ->
                    game = FourWins()
                }
                /*   ws.onMessage { ctx ->
                       broadcastMessage(userUsernameMap[ctx]!!, ctx.message())
                   }*/
            }

            //game.toString()
            app.get("/move") { ctx: Context ->
                if (canPlay) {
                    val input = ctx.queryParam("pos")!!.toInt()
                    // if (game.IsValidMove(input))
                    game = game.Move(input)
                    session.send("0 " + game.toString())
                 //   ctx.result(game.toString())
                    canPlay = false
                    startThread()
                    //ProceedAI()

                } else {
                    session.send("1 " + "Its not your turn! AI still calculating next move")
                }
            }
            app.get("/newgame") { ctx: Context ->
                game = FourWins()
                ctx.result(game.toString())
            }
            app.get("/render") { ctx: Context ->
                ctx.result(game.toString())
            }
            app.get("/undo") { ctx: Context ->

                var prev = game.Undo()
                if (prev != null) {
                    //println("Sucessfull undo move")
                    game = prev as FourWins
                } else {
                    //println("Null no prev board found")
                    //ctx.result("Null no prev board found")
                }
                ctx.result(game.toString())
            }

            app.get("/rows") { ctx: Context ->
                ctx.result(game.toString())
            }
            app.post("/") { ctx ->
                // some code
                game.toString()
            }
        }


    }
    fun startThread(){
        val thread = Thread(AIProceeding(session,game,this))
        thread.start()
    }

    class AIProceeding : Thread {
        lateinit var session: WsConnectContext
        lateinit var game: FourWins
        lateinit var app: App

        constructor(session: WsConnectContext, game: FourWins, app: App) {
            this.session = session
            this.game = game
            this.app = app
        }

        override fun run() {
            if (session != null) {
                //    session.send("1 " + "AI is calculating next move")
            }

            //        return negamax(P, -1, 1);
            println("Start thinking...")
            var startTime = System.nanoTime()
            game.SetStartTime(startTime, 10)
            var nextMove = game.newAlphaBeta(20, -21, 21, true, 8)
            app.game = game.Move(nextMove[1] % 7)
            var totalTime = (System.nanoTime() - startTime)
            val elapsedTimeInSecond = totalTime.toDouble() / 1000000000
            if (session != null) {
                session.send("1" + "Time for calculation : " + elapsedTimeInSecond)
                session.send("0 " + app.game.toString())
                //  println("Send: "+ game.toString())
            }
            app.game.SaveDB()
            app.canPlay = true
        }
    }

    fun ProceedAI() {
        if (session != null) {
            //    session.send("1 " + "AI is calculating next move")
        }

        //        return negamax(P, -1, 1);
        println("Start thinking...")
        var startTime = System.nanoTime()
        game.SetStartTime(startTime, 10)
        var nextMove = game.AlphaBeta(20, -21, 21, true, 8)
        game = game.Move(nextMove[1] % 7)
        var totalTime = (System.nanoTime() - startTime)
        val elapsedTimeInSecond = totalTime.toDouble() / 1000000000
        if (session != null) {
            session.send("1" + "Time for calculation : " + elapsedTimeInSecond)
            session.send("0 " + game.toString())
            //  println("Send: "+ game.toString())
        }
        canPlay = true
    }


    private fun CalcualteAIMove() {

    }


}

class Pfannkuchen() {
    var _haltbar = true
    var _name = "";


    fun Abgelaufen() {
        _haltbar = false
    }

    override fun toString(): String {
        return _name + "Pfannkuchen haltbar? " + _haltbar
    }
}


fun main(args: Array<String>) {
    App()

}



