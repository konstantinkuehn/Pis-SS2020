/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package FourWins

import io.javalin.Javalin
import io.javalin.http.Context
import io.javalin.websocket.WsConnectContext
import io.javalin.websocket.WsContext

class App {
    private val userUsernameMap = HashMap<WsContext, String>()
    private var nextUserNumber = 1
    lateinit var session: WsConnectContext
    var game: GameEngine
    var canPlay = true

    init {
        game = FourWins()
        val app = Javalin.create { config ->
            config.addStaticFiles("/public")

        }.start(7070)

        app.apply {
            ws("/") { ws ->
                ws.onConnect { ctx ->
                    session = ctx
                    ctx.send("0 " + game.toString())
                }
                ws.onClose { ctx ->
                    //   game = FourWins()
                }
            }

            //game.toString()
            app.get("/move") { ctx: Context ->
                if (canPlay) {
                    val input = ctx.queryParam("pos")!!.toInt()
                    // if (game.IsValidMove(input))
                    game = game.Move(input)
                    if (game.MatchWon()) {
                        session.send("0 " + game.toString())
                        session.send("1 " + "You win")
                        session.send("2 " + GetInteractionRenderer())
                        println("Player won round")
                    } else {
                        session.send("0 " + game.toString())
                        //   ctx.result(game.toString())
                        canPlay = false
                        startThread()
                    }
                    // ProceedAI()

                } else {
                    session.send("1 " + "Its not your turn! AI still calculating next move")
                }
            }
            app.get("/newgame") { ctx: Context ->
                game = FourWins()
                canPlay = true
                session.send("2 " + GetInteractionRenderer(true))
                ctx.result(game.toString())
            }
            app.get("/render") { ctx: Context ->
                ctx.result(game.toString())
            }

            app.get("/tests") { ctx: Context ->
                println("Execute tests")
            }
            app.get("/flip") { ctx: Context ->
                println("Flipped Colors")
                game.FlipColor()
                ctx.result(game.toString())
            }
            app.get("/undo") { ctx: Context ->

                var prev = game.Undo()
                if (prev != null) {
                    //println("Sucessfull undo move")
                    game = prev as FourWins
                } else {
                    //println("Null no prev board found")
                    //ctx.result("Null no prev board found")
                }
                ctx.result(game.toString())
            }

            app.get("/rows") { ctx: Context ->
                ctx.result(game.toString())
            }
            app.post("/") { ctx ->
                // some code
                game.toString()
            }
        }


    }

    lateinit var thread: Thread
    fun startThread() {
        thread = Thread(AIProceeding(session, game, this))
        thread.start()
    }


    class AIProceeding : Thread {
        lateinit var session: WsConnectContext
        lateinit var game: GameEngine
        lateinit var app: App

        constructor(session: WsConnectContext, game: GameEngine, app: App) {
            this.session = session
            this.game = game
            this.app = app
        }

        override fun run() {
            if (session != null) {
                //    session.send("1 " + "AI is calculating next move")
            }

            //        return negamax(P, -1, 1);
            if (!game.MatchWon()) {
                session.send("2 " + app.GetInteractionRenderer())

                var startTime = System.nanoTime()
                game.SetStartTime(startTime, 2)
                var nextMove = game.CalculateBestMove(1000, -21, 21, true)
                app.game = game.Move(nextMove[1] % 7)
                var totalTime = (System.nanoTime() - startTime)
                val elapsedTimeInSecond = totalTime.toDouble() / 1000000000
                if (session != null) {

                    if (app.game.MatchWon()) {
                        session.send("2 " + app.GetInteractionRenderer())
                        session.send("1 " + "You Lost")
                        session.send("0 " + app.game.toString())

                    } else {

                        session.send("1" + "Time for calculation : " + elapsedTimeInSecond)
                        session.send("0 " + app.game.toString())
                    }
                    //  println("Send: "+ game.toString())
                }
                app.game.SaveDB()
                app.canPlay = true
                session.send("2 " + app.GetInteractionRenderer())

            }
        }
    }

    fun GetInteractionRenderer(force:Boolean = false): String {

        var toReturn = ""
        toReturn += "<tr>\n"
        for (index in 0..6) {
            var value: Int = 0
            value = if (game.MatchWon() || !canPlay)
                1
            else
                0

            if(force){
                value= 0
            }
            when (value) {
                0 -> toReturn += String.format("  <td onclick=\"sendMove(%d)\" bgcolor=\"%s\"></td>\n", index, "white")
                1 -> toReturn += String.format("  <td bgcolor=\"%s\" onMouseOver=\"this.style.backgroundColor='%s'\"></td>\n", "black", "black")
            }

        }
        toReturn += "</tr>\n"
        return toReturn
    }


}

class Pfannkuchen() {
    var _haltbar = true
    var _name = "";


    fun Abgelaufen() {
        _haltbar = false
    }

    override fun toString(): String {
        return _name + "Pfannkuchen haltbar? " + _haltbar
    }
}


fun main(args: Array<String>) {
    App()

}



